import copy, random
from tqdm import tqdm

from models.general import *
from models.prototype import SearchAlgorithm


class AntColonyOptimization(SearchAlgorithm):
    def __init__(self, problem_instance: 'DeliveryProblem', *, truck_types: list['Truck'],
                 num_ants: int = 50, evaporation_rate: float = 0.1, pheromone_deposit: float = 1.0,
                 alpha: float = 1.0, beta: float = 2.0) -> None:
        """
        Initialize the Ant Colony Optimization algorithm.

        Parameters:
        - problem_instance (DeliveryProblem): The problem instance to be solved.
        - truck_types (list): List of available truck types.
        - num_ants (int): Number of ants in the colony.
        - evaporation_rate (float): Rate at which pheromones evaporate.
        - pheromone_deposit (float): Amount of pheromone deposited per solution.
        - alpha (float): Weight of pheromone importance.
        - beta (float): Weight of heuristic importance.
        """
        super().__init__(problem_instance, truck_types=truck_types)
        self.truck_types = list(truck_types)  # Ensure truck types are a list
        self.num_ants = num_ants
        self.generations = config.iterations // num_ants  # Total iterations split among generations
        self.evaporation_rate = evaporation_rate
        self.pheromone_deposit = pheromone_deposit
        self.alpha = alpha
        self.beta = beta
        self.pheromone_matrix = self.__initialize_pheromone_matrix()

    def search(self) -> 'DeliveryProblem':
        """
        Perform the Ant Colony Optimization search to find the best solution.

        Returns:
        - DeliveryProblem: The best solution found by the algorithm.
        """
        best_solution = None
        best_cost = float('inf')

        if self.debug: print("Running Ant Colony Optimization...")
        for generation in tqdm(range(self.generations), desc="ACO Progress", position = 2, leave=False):
            solutions = []

            # Each ant constructs a solution
            for ant in range(self.num_ants):
                solution = self.__construct_solution()
                cost = self._evaluate_solution(solution)
                solutions.append((solution, cost))

                if cost < best_cost:
                    best_solution = solution
                    best_cost = cost

            # Update pheromone levels
            self.__update_pheromones(solutions)

            # Log progress
            if generation % 5 == 0 and self.debug:
                print(f"Generation {generation + 1}: Best Cost = {best_cost}")

        return best_solution

    def __initialize_pheromone_matrix(self):
        """
        Initialize the pheromone matrix with default values using unique IDs for (order, truck).
        """
        return {(order.order_id, truck.truck_id): 1.0 for order in self.problem_instance.orders for truck in self.truck_types}

    def __construct_solution(self) -> 'DeliveryProblem':
        """
        Construct a solution for an ant by assigning orders to trucks and optimizing routes.

        Returns:
        - DeliveryProblem: A complete solution generated by the ant.
        """
        solution = copy.deepcopy(self.problem_instance)
        solution.routes = []

        for order in solution.orders:
            # Calculate probabilities for truck selection
            probabilities = self.__calculate_truck_probabilities(order)
            selected_truck = random.choices(self.truck_types, weights=probabilities, k=1)[0].copy()

            # Dynamically add to pheromone_matrix for new truck_id
            key = (order.order_id, selected_truck.truck_id)
            if key not in self.pheromone_matrix:
                self.pheromone_matrix[key] = 1.0  # Initialize if missing

            # Assign order to truck
            solution._DeliveryProblem__assign_order_to_truck(order, truck=selected_truck)

        # Optimize order delivery sequence
        for route in solution.routes:
            shuffled_orders = self.__shuffle_orders_with_constraints(route.orders)
            route.orders = shuffled_orders
            route.calculate_route_details()

        return solution

    def __calculate_truck_probabilities(self, order: 'Order') -> list:
        """
        Calculate probabilities for selecting each truck based on pheromone and heuristic values.

        Parameters:
        - order (Order): The order to be assigned to a truck.

        Returns:
        - list: A list of probabilities corresponding to each truck.
        """
        probabilities = []
        for truck in self.truck_types:
            pheromone = self.pheromone_matrix.get((order.order_id, truck.truck_id), 1.0)
            heuristic = 1 / (truck.truck_cost + 1e-6)  # Inverse cost as heuristic
            probabilities.append((pheromone ** self.alpha) * (heuristic ** self.beta))
        total = sum(probabilities)
        return [p / total for p in probabilities]

    def __update_pheromones(self, solutions: list):
        """
        Update pheromone levels based on the solutions found by the ants.

        Parameters:
        - solutions (list): A list of tuples (solution, cost).
        """
        # Evaporation step
        for key in self.pheromone_matrix:
            self.pheromone_matrix[key] *= (1 - self.evaporation_rate)

        # Deposit pheromones proportional to solution quality
        for solution, cost in solutions:
            pheromone_to_deposit = self.pheromone_deposit / cost
            for route in solution.routes:
                for order in route.orders:
                    key = (order.order_id, route.truck.truck_id)
                    if key not in self.pheromone_matrix:
                        self.pheromone_matrix[key] = 1.0  # Ensure existence
                    self.pheromone_matrix[key] += pheromone_to_deposit

    def __shuffle_orders_with_constraints(self, orders: list) -> list:
        """
        Shuffle orders while respecting time constraints and avoiding invalid routes.

        Parameters:
        - orders (list): A list of orders to be shuffled.

        Returns:
        - list: A valid shuffled order list.
        """
        for _ in range(10):  # Attempt multiple shuffles to find a valid one
            shuffled = orders[:]
            random.shuffle(shuffled)
            if self.__is_route_valid(shuffled):
                return shuffled
        return orders  # Return original if no valid shuffle found

    def __is_route_valid(self, orders: list) -> bool:
        """
        Check if the shuffled order list meets the delivery time constraints.

        Parameters:
        - orders (list): A list of orders to validate.

        Returns:
        - bool: True if valid, False otherwise.
        """
        total_time = 0
        for i in range(len(orders) - 1):
            distance = self.problem_instance.city_manager.distance_between_cities(
                city1=orders[i].start_city, city2=orders[i + 1].start_city)
            travel_time = distance / orders[i].start_city.city_id  # Assuming truck speed
            total_time += travel_time
            if total_time > (orders[i].end_time - orders[i].start_time).total_seconds() / 3600:
                return False
        return True
